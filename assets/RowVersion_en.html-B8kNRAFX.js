import{_ as t,c as o,a as s,b as n,d as a,e as r,r as l,o as d}from"./app-DZFgIm2e.js";const c="/Vueblog/assets/RowversionConvertBigint-BGYgnPec.png",p={},h={id:"_1-use-optimistic-locks-to-prevent-duplicate-commits",tabindex:"-1"},u={class:"header-anchor",href:"#_1-use-optimistic-locks-to-prevent-duplicate-commits"},v={href:"https://www.sqlserver-dba.com/2012/12/sql-server-concurrency-control-optimistic-and-pessimistic.html#google_vignette",target:"_blank",rel:"noopener noreferrer"};function m(b,e){const i=l("ExternalLinkIcon");return d(),o("div",null,[e[3]||(e[3]=s(`<h1 id="sql-server-rowversion-usage" tabindex="-1"><a class="header-anchor" href="#sql-server-rowversion-usage"><span><strong>SQL Server RowVersion Usage</strong></span></a></h1><h2 id="_1-what-does-rowversion-do" tabindex="-1"><a class="header-anchor" href="#_1-what-does-rowversion-do"><span>1. What does rowversion do?</span></a></h2><p>When a data table is updated, how do I characterize the order in which each data row is updated? The easiest way to do this is to use the RowVersion field, which is similar to the TimeStamp type, except that TimeStamp is obsolete and should be avoided in product design and should be replaced with RowVersion.</p><p>RowVersion is a self-incrementing data type, which is only used to define the column type of the data table, and its value occupies a fixed size of 8 bytes, which is a unique, binary number automatically generated by the SQL Server database, and the value is stored in binary(8).</p><p>RowVersion is used to stamp the version of each row of data in a data table, and the storage size is 8 bytes. The RowVersion data type is an eternally increasing number that does not retain a date or time, but you can use RowVersion to compare the order in which the rows of data were updated, and if @rv1&lt;@rv2, then the update of the @rv2 occurred after the @rv1.</p><h2 id="_2-how-is-the-rowversion-incremented" tabindex="-1"><a class="header-anchor" href="#_2-how-is-the-rowversion-incremented"><span>2. How is the RowVersion incremented?</span></a></h2><p>Each database has only one self-incrementing count, which is the DataBase RowVersion, which is incremented each time the Insert or Update command is executed on a table with a RowVersion field. A data table can have a maximun of one RowVersion field, and whenever you run the Insert or Update command on the data table, the filed will be updated to the lasted value of the counter.</p><h3 id="_1-features-of-the-rowversion-field" tabindex="-1"><a class="header-anchor" href="#_1-features-of-the-rowversion-field"><span>1. Features of the Rowversion field:</span></a></h3><ol><li>Since each Database has only one Counter, the value of RowVersion is unique in the current databases, and the value of this field is different for all tables with RowVersion filed.</li><li>The RowVersion of the database is only incremented and not rolled back; If a transaction that updates table data(Insert or Update) is rolled back, the value of the RowVersion filed of the data table is rolled back, however, the RowVersion of the database is not rolled back.</li><li>The value is automatically assingned by the database, and can&#39;t be explicitly assigned in the Insert or Update commands.</li></ol><p>If the current value is different from the RowVersion value of the last record,it means that the data row has been updated.</p><h3 id="_2-global-variables-dbts" tabindex="-1"><a class="header-anchor" href="#_2-global-variables-dbts"><span>2. Global variables @@DBTS</span></a></h3><p>Global variable @@DBTS(Database TimeStamp).The data type used to return the Rowversion of the current database, @@DBTS The return values is varbinary(8), which is unique across the entire database. The value of the counter is incremented everytime a table in the database containing the RowVersion field executeds the Insert or Update command. The value of the @@DBTS is not rolled back,even when a transaction is rolled back, or when an Insert or Update transcation fails.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">select</span> @<span class="token variable">@DBTS</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_3-next-database-rowversion" tabindex="-1"><a class="header-anchor" href="#_3-next-database-rowversion"><span>3. Next Database RowVersion</span></a></h2><p>The none-deterministic function MIN_ACTIVE_ROWVERSION() is used to return the next RowVersion values of the current database, which is @@DBTS+1.</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">select</span> @<span class="token variable">@DBTS</span> <span class="token keyword">as</span> dbts<span class="token punctuation">,</span> MIN_ACTIVE_ROWVERSION<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> min_active</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="_2-how-to-use-rowversion" tabindex="-1"><a class="header-anchor" href="#_2-how-to-use-rowversion"><span>2. How to use RowVersion?</span></a></h1><p>RowVersion is used to characterize the order in which rows are updated, and its value is unique in the database.</p><h2 id="_1-create-a-rowversion-filed" tabindex="-1"><a class="header-anchor" href="#_1-create-a-rowversion-filed"><span>1. Create a RowVersion filed</span></a></h2><p>Run the Created command to create a table that contains a filed type RowVersion</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">alter</span> <span class="token keyword">table</span> yourtable <span class="token keyword">add</span> RowVersionStamp Rowversion<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_2-insert-a-new-line" tabindex="-1"><a class="header-anchor" href="#_2-insert-a-new-line"><span>2. Insert a new line</span></a></h2><p>The value of the RowVersion field is automatically incremented and cannot be assigned to the column, however, when a row of data is inserted, the field is automatically set to the value of the global variable @@DBTS</p><h2 id="_3-update-the-data-rows" tabindex="-1"><a class="header-anchor" href="#_3-update-the-data-rows"><span>3. Update the data rows</span></a></h2><p>When the value of any column in the data table changes, the RowVersion field is automatically set to the value of the global variable @@DBTS</p><h2 id="_4-the-value-of-the-rowversion-field-will-not-be-rolled-back" tabindex="-1"><a class="header-anchor" href="#_4-the-value-of-the-rowversion-field-will-not-be-rolled-back"><span>4. The value of the RowVersion field will not be rolled back</span></a></h2><p>When an update (INSERT or UPDATE) transaction is rolled back, the value of the RowVersion field is not rolled back, the value of the @@DBTS is used:</p><p>When a transaction is rolled back, the value of the RowVersion field is not rolled back, but the value of the RowVersion field of the database is incremented, because the database counter is not in the transaction, and its value is only incremented, not rolled back, so once the value of the RowVersion field is updated, it will not be rolled back.</p><h2 id="_5-convert-rowversion-to-int-bigint-and-timestamp" tabindex="-1"><a class="header-anchor" href="#_5-convert-rowversion-to-int-bigint-and-timestamp"><span>5.Convert Rowversion to int,bigint and timestamp</span></a></h2><h3 id="_5-1-rowversionasint-will-give-you-the-lower-4-bytes-as-an-int-however-it-will-be-null" tabindex="-1"><a class="header-anchor" href="#_5-1-rowversionasint-will-give-you-the-lower-4-bytes-as-an-int-however-it-will-be-null"><span>5.1 <code>RowVersionAsInt</code> will give you the lower 4 bytes as an <code>int</code>, however ,it will be null.</span></a></h3><h3 id="_5-2-rowversionasbigint-will-give-you-the-full-8-byte-rowversion-as-a-bigint" tabindex="-1"><a class="header-anchor" href="#_5-2-rowversionasbigint-will-give-you-the-full-8-byte-rowversion-as-a-bigint"><span>5.2 <code>RowVersionAsBigInt</code> will give you the full 8-byte rowversion as a <code>BIGINT</code>.</span></a></h3><h3 id="_5-3-in-sql-server-the-rowversion-data-type-is-a-unique-binary-number-within-a-database-that-automatically-increments-whenever-a-row-is-inserted-or-updated-so-we-don-t-need-to-convert-to-timestamp" tabindex="-1"><a class="header-anchor" href="#_5-3-in-sql-server-the-rowversion-data-type-is-a-unique-binary-number-within-a-database-that-automatically-increments-whenever-a-row-is-inserted-or-updated-so-we-don-t-need-to-convert-to-timestamp"><span>5.3 In SQL Server, the <code>rowversion</code> data type is a unique binary number within a database that automatically increments whenever a row is inserted or updated. So, we don&#39;t need to convert to <code>timestamp</code>.</span></a></h3><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">select</span> </span>
<span class="line">	id<span class="token punctuation">,</span></span>
<span class="line">	RowVersionStamp<span class="token punctuation">,</span></span>
<span class="line">    CAST<span class="token punctuation">(</span>CAST<span class="token punctuation">(</span>RowVersionStamp <span class="token keyword">AS</span> <span class="token keyword">BINARY</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> RowVersionAsInt<span class="token punctuation">,</span></span>
<span class="line">	CAST<span class="token punctuation">(</span>RowVersionStamp <span class="token keyword">AS</span> <span class="token keyword">BIGINT</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> RowVersionAsBigInt</span>
<span class="line"><span class="token keyword">from</span> TestJson</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-4-the-result-are-shown-blow" tabindex="-1"><a class="header-anchor" href="#_5-4-the-result-are-shown-blow"><span>5.4 The result are shown blow</span></a></h3><div><img src="`+c+`" title="Rowversion Convert Bigint"></div><h2 id="_4-customzie-rowversion" tabindex="-1"><a class="header-anchor" href="#_4-customzie-rowversion"><span>4. customzie RowVersion</span></a></h2><h3 id="_1-why-we-need-to-define-the-customzie-rowversion" tabindex="-1"><a class="header-anchor" href="#_1-why-we-need-to-define-the-customzie-rowversion"><span>1. Why we need to define the customzie RowVersion?</span></a></h3><ol><li>In some cases, we need to see how many times a table has been changed, but SQLSever&#39;s Rowversion is database level oriented, not table level oriented. And it is binary 8 bytes, can not directly represent the number of changes in the table, size, time. So, we can put the table RowVersion field we want to define as bigint,timestamp type.</li><li>We control RowVersion field changes in two ways, one is a trigger, and the other is code control.</li></ol><h3 id="_2-using-trigger-define-rowversion" tabindex="-1"><a class="header-anchor" href="#_2-using-trigger-define-rowversion"><span>2. Using trigger define RowVersion</span></a></h3><ol><li>The advantage of a trigger defining Rowversion is that you do not need to write this logic in the code. The Database automatically changes the value of the RowVersion<br> filed when it detects that the table row data has changed.</li><li>define RowVersion filed as Bigint</li></ol><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- alter table filed</span></span>
<span class="line"><span class="token keyword">alter</span> <span class="token keyword">table</span> your <span class="token keyword">table</span> <span class="token keyword">add</span> version <span class="token keyword">bigint</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">-- add trigger</span></span>
<span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trg_yourtable_Update</span>
<span class="line"><span class="token keyword">ON</span> yourtable</span>
<span class="line"><span class="token keyword">AFTER</span> <span class="token keyword">UPDATE</span></span>
<span class="line"><span class="token keyword">AS</span></span>
<span class="line"><span class="token keyword">BEGIN</span></span>
<span class="line">    <span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">UPDATE</span> yourtable</span>
<span class="line">    <span class="token keyword">SET</span> Version <span class="token operator">=</span> Version <span class="token operator">+</span> <span class="token number">1</span></span>
<span class="line">    <span class="token keyword">FROM</span> yourtable u</span>
<span class="line">    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> inserted i <span class="token keyword">ON</span> u<span class="token punctuation">.</span>Id <span class="token operator">=</span> i<span class="token punctuation">.</span>Id<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">END</span><span class="token punctuation">;</span></span>
<span class="line">GO</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>define RowVersion as TimeStamp</li></ol><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token comment">-- Add the version column with default value as current timestamp</span></span>
<span class="line"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> yourtable <span class="token keyword">add</span> version DATETIME2 <span class="token keyword">DEFAULT</span> <span class="token punctuation">(</span>GETDATE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- Create the trigger to update the LastUpdated column on row update</span></span>
<span class="line"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trg_yourtable_version_Timestamp</span>
<span class="line"><span class="token keyword">ON</span> yourtable</span>
<span class="line"><span class="token keyword">AFTER</span> <span class="token keyword">UPDATE</span></span>
<span class="line"><span class="token keyword">AS</span></span>
<span class="line"><span class="token keyword">BEGIN</span></span>
<span class="line">    <span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">UPDATE</span> yourtable</span>
<span class="line">    <span class="token keyword">SET</span> version <span class="token operator">=</span> GETDATE<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">FROM</span> yourtable u</span>
<span class="line">    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> inserted i <span class="token keyword">ON</span> u<span class="token punctuation">.</span>Id <span class="token operator">=</span> i<span class="token punctuation">.</span>Id<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">END</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-code-control-rowversion" tabindex="-1"><a class="header-anchor" href="#_3-code-control-rowversion"><span>3. code control rowversion</span></a></h3><p>Instead of manually modifying the data in the database table, we can modify RowVersion in the code control area and carry the RowVersion field with us every time we insert and update.</p><h2 id="_5-why-microsoft-does-not-recommend-using-timestamps-to-replace-rowversion" tabindex="-1"><a class="header-anchor" href="#_5-why-microsoft-does-not-recommend-using-timestamps-to-replace-rowversion"><span>5. Why Microsoft does not recommend using <code>timestamps</code> to replace <code>RowVersion</code>?</span></a></h2><h3 id="_1-different-purpose-and-functionality" tabindex="-1"><a class="header-anchor" href="#_1-different-purpose-and-functionality"><span>1. Different Purpose and Functionality</span></a></h3><ul><li><p>The <code>timestamps</code> data type(now referred to as <code>RowVersion</code>) is designed specificlly to support optimistic concurrency control and help with data versioning. It provides a unique binary number that changes every time a row is modified.</p></li><li><p><code>Timestamps</code>, as they might be thought of in other contexts(like datatime stamps), are used for recording the exact time when event occurs and are not intended to handle concurrency control or uniquely identify row versions.</p></li></ul><h3 id="_2-concurrency-control" tabindex="-1"><a class="header-anchor" href="#_2-concurrency-control"><span>2. Concurrency control</span></a></h3><ul><li><code>RowVersion</code> ensures each version of a row is unique and sequentially increments with each change, which is crucial for detecting modifications and mainttaining data integrity in concurrent environments.</li><li>Using a datetime-based timestamp for concurrency control can lead to collisions(two updates occurring within the same timestamp precision) and is not sequential, making it unreliable for this purpose.</li></ul><h3 id="_3-performance" tabindex="-1"><a class="header-anchor" href="#_3-performance"><span>3. Performance</span></a></h3><ul><li><code>rowversion</code> is efficient and optimized for version tracking by the SQL Server engine. It is stored as a binary value, ensuring minimal storage overhead and fast comparisons.</li><li>Datetime values are larger and more complex, leading to increased storage requirements and slower performance in comparison operations, especially when dealing with high transaction volumes.</li></ul><h3 id="_4-precision-and-accuracy" tabindex="-1"><a class="header-anchor" href="#_4-precision-and-accuracy"><span>4. Precision and Accuracy</span></a></h3><ul><li><code>rowversion</code> guarantees unique values across the database, providing absolute accuracy in identifying changes.</li><li>Implementing similar functionality with datetime timestamps would require additional custom logic and code, increasing the complexity and potential for errors.</li></ul><h3 id="_5-functionality-and-usability" tabindex="-1"><a class="header-anchor" href="#_5-functionality-and-usability"><span>5. Functionality and Usability</span></a></h3><ul><li><code>rowversion</code> integrates seamlessly with SQL Serverâ€™s native support for optimistic concurrency control, making it easy to implement and use.</li></ul><h3 id="_6-best-practices-and-recommendations" tabindex="-1"><a class="header-anchor" href="#_6-best-practices-and-recommendations"><span>6. Best Practices and Recommendations</span></a></h3><ul><li>Microsoft provides comprehensive guidance and best practices for using rowversion to manage row versioning. Following these best practices ensures the database system remains reliable, performant, and easier to maintain.</li><li>Diverging from recommended practices, like using datetime stamps for row versioning, can lead to unforeseen issues, lack of support, and increased technical debt.</li></ul><p>In summary, Microsoft does not recommend using datetime <code>timestamps</code> to replace <code>rowversion</code> due to significant differences in functionality, precision, performance, and reliability. Sticking with the rowversion data type ensures robust concurrency control, optimal performance, and adherence to best practices in SQL Server database management.</p><h2 id="_6-net-control-sqlserver-rowversion" tabindex="-1"><a class="header-anchor" href="#_6-net-control-sqlserver-rowversion"><span>6. .NET control SQLServer RowVersion</span></a></h2>`,60)),n("h3",h,[n("a",u,[n("span",null,[e[1]||(e[1]=a("1.Use ",-1)),n("a",v,[e[0]||(e[0]=a("optimistic locks",-1)),r(i)]),e[2]||(e[2]=a(" to prevent duplicate commits",-1))])])]),e[4]||(e[4]=s(`<h3 id="precondition" tabindex="-1"><a class="header-anchor" href="#precondition"><span>precondition:</span></a></h3><h4 id="_1-user-open-the-edit-ui-and-update-the-data" tabindex="-1"><a class="header-anchor" href="#_1-user-open-the-edit-ui-and-update-the-data"><span>1. User open the edit UI and update the data;</span></a></h4><h4 id="_2-user-click-submit-button-after-he-or-she-updated-all-data" tabindex="-1"><a class="header-anchor" href="#_2-user-click-submit-button-after-he-or-she-updated-all-data"><span>2. User click submit button after he or she updated all data;</span></a></h4><h3 id="principle" tabindex="-1"><a class="header-anchor" href="#principle"><span>Principle:</span></a></h3><h4 id="_1-when-the-user-opens-the-edit-box-for-too-long-someone-else-has-modified-the-record-and-he-may-delete-the-updated-data-before-commiting-we-need-a-time-filed-to-compare-with-the-version-of-the-database-to-determine-whether-the-data-has-been-changed" tabindex="-1"><a class="header-anchor" href="#_1-when-the-user-opens-the-edit-box-for-too-long-someone-else-has-modified-the-record-and-he-may-delete-the-updated-data-before-commiting-we-need-a-time-filed-to-compare-with-the-version-of-the-database-to-determine-whether-the-data-has-been-changed"><span>1. When the user opens the edit box for too long,someone else has modified the record, and he may delete the updated data before commiting.We need a time filed to compare with the version of the database to determine whether the data has been changed.</span></a></h4><h3 id="procedure" tabindex="-1"><a class="header-anchor" href="#procedure"><span>Procedure</span></a></h3><h4 id="_1-open-two-browsers-edit-the-same-record-the-user-a-save-it-first-and-then-the-user-b-save-it-again-finially-this-scenario-can-be-repeated" tabindex="-1"><a class="header-anchor" href="#_1-open-two-browsers-edit-the-same-record-the-user-a-save-it-first-and-then-the-user-b-save-it-again-finially-this-scenario-can-be-repeated"><span>1. Open two browsers, edit the same record. The user A save it first, and then the user B save it again. Finially, this scenario can be repeated.</span></a></h4><h4 id="_2-because-it-is-the-same-record-itself-does-not-exist-concurrent-the-editing-interface-will-not-refresh-the-data-for-a-day-someone-submits-the-data-will-recover-another-submiting" tabindex="-1"><a class="header-anchor" href="#_2-because-it-is-the-same-record-itself-does-not-exist-concurrent-the-editing-interface-will-not-refresh-the-data-for-a-day-someone-submits-the-data-will-recover-another-submiting"><span>2. Because it is the same record itself does not exist concurrent, the editing interface will not refresh the data for a day.Someone submits the data will recover another submiting.</span></a></h4><h3 id="code-sqlsugar-sqlserver-net8" tabindex="-1"><a class="header-anchor" href="#code-sqlsugar-sqlserver-net8"><span>Code(SQLSugar + SQLServer + .NET8)</span></a></h3><h4 id="entity" tabindex="-1"><a class="header-anchor" href="#entity"><span>Entity:</span></a></h4><div class="language-C# line-numbers-mode" data-highlighter="prismjs" data-ext="C#" data-title="C#"><pre><code><span class="line">public class Test</span>
<span class="line">{</span>
<span class="line">    [SugarColumn(IsPrimaryKey =true)]</span>
<span class="line">    public long Id { get; set;}</span>
<span class="line"></span>
<span class="line">    [SugarColumn(</span>
<span class="line">             IsEnableUpdateVersionValidation = true, </span>
<span class="line">             IsOnlyIgnoreInsert=true,</span>
<span class="line">             IsOnlyIgnoreUpdate=true,</span>
<span class="line">             ColumnDataType=&quot;timestamp&quot; </span>
<span class="line">              )] </span>
<span class="line">    // Only the SQL Server entity is byte, another should be timestamp or another type</span>
<span class="line">    public byte[]? Version { get; set;}</span>
<span class="line">    </span>
<span class="line">    // additional filed</span>
<span class="line">    [SugarColumn(IsIgnore = true)]</span>
<span class="line">    public long TimeStampVersionLong</span>
<span class="line">    {</span>
<span class="line"></span>
<span class="line">        get =&gt; Version != null ? BitConverter.ToInt64(Version.Reverse().ToArray(), 0) : 0;</span>
<span class="line">        set =&gt; Version = BitConverter.GetBytes(value).Reverse().ToArray();</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="submit-interface" tabindex="-1"><a class="header-anchor" href="#submit-interface"><span>Submit Interface</span></a></h4><div class="language-C# line-numbers-mode" data-highlighter="prismjs" data-ext="C#" data-title="C#"><pre><code><span class="line">[HttpPost]</span>
<span class="line">[Description(&quot;PostTestData&quot;)]</span>
<span class="line">public async Task&lt;IReturnModel&lt;VerTest&gt;&gt; PostTestData(Test testDto)</span>
<span class="line">{  </span>
<span class="line">    await _db.Updateable(testDto).IsEnableUpdateVersionValidation().Where(t=&gt;t.Id==testDto.Id).ExecuteCommandAsync();</span>
<span class="line">    var data = await  _db.Queryable&lt;VerTest&gt;().Where(t=&gt;t.Id==testDto.Id).FirstAsync();</span>
<span class="line">    return ReturnModel.Successful(&quot;success&quot;,data);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="principle-1" tabindex="-1"><a class="header-anchor" href="#principle-1"><span>Principle</span></a></h4><div class="language-C# line-numbers-mode" data-highlighter="prismjs" data-ext="C#" data-title="C#"><pre><code><span class="line">//QueryThisData, Id filed must exist and must be primary key</span>
<span class="line">var data = db.Queryable&lt;Test&gt;().InSingle(id);</span>
<span class="line">  </span>
<span class="line">//Sucess (data.Version is equal to the database Version)</span>
<span class="line">db.Updateable(data).IsEnableUpdateVersionValidation().ExecuteCommandAsync();//the database version will update after executed</span>
<span class="line">  </span>
<span class="line">//faild (data.Version is not equal to the database Version )</span>
<span class="line">db.Updateable(data).IsEnableUpdateVersionValidation().ExecuteCommandAsync();</span>
<span class="line"></span>
<span class="line">//how to know the VersionExceptions or another</span>
<span class="line">//catch the exception </span>
<span class="line">throw new VersionExceptions //if the exception is  VersionExceptions , we can know this is concurrency exceptions</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,15))])}const f=t(p,[["render",m]]),g=JSON.parse(`{"path":"/blogs/Skills/NET/RowVersion/RowVersion_en.html","title":"SQL Server RowVersion in the SQL Sugar","lang":"en-US","frontmatter":{"title":"SQL Server RowVersion in the SQL Sugar","date":"2025/11/14","tags":["NET"],"categories":["Skills"]},"headers":[{"level":2,"title":"1. What does rowversion do?","slug":"_1-what-does-rowversion-do","link":"#_1-what-does-rowversion-do","children":[]},{"level":2,"title":"2. How is the RowVersion incremented?","slug":"_2-how-is-the-rowversion-incremented","link":"#_2-how-is-the-rowversion-incremented","children":[{"level":3,"title":"1. Features of the Rowversion field:","slug":"_1-features-of-the-rowversion-field","link":"#_1-features-of-the-rowversion-field","children":[]},{"level":3,"title":"2. Global variables @@DBTS","slug":"_2-global-variables-dbts","link":"#_2-global-variables-dbts","children":[]}]},{"level":2,"title":"3. Next Database RowVersion","slug":"_3-next-database-rowversion","link":"#_3-next-database-rowversion","children":[]},{"level":2,"title":"1. Create a RowVersion filed","slug":"_1-create-a-rowversion-filed","link":"#_1-create-a-rowversion-filed","children":[]},{"level":2,"title":"2. Insert a new line","slug":"_2-insert-a-new-line","link":"#_2-insert-a-new-line","children":[]},{"level":2,"title":"3. Update the data rows","slug":"_3-update-the-data-rows","link":"#_3-update-the-data-rows","children":[]},{"level":2,"title":"4. The value of the RowVersion field will not be rolled back","slug":"_4-the-value-of-the-rowversion-field-will-not-be-rolled-back","link":"#_4-the-value-of-the-rowversion-field-will-not-be-rolled-back","children":[]},{"level":2,"title":"5.Convert Rowversion to int,bigint and timestamp","slug":"_5-convert-rowversion-to-int-bigint-and-timestamp","link":"#_5-convert-rowversion-to-int-bigint-and-timestamp","children":[{"level":3,"title":"5.1 RowVersionAsInt will give you the lower 4 bytes as an int, however ,it will be null.","slug":"_5-1-rowversionasint-will-give-you-the-lower-4-bytes-as-an-int-however-it-will-be-null","link":"#_5-1-rowversionasint-will-give-you-the-lower-4-bytes-as-an-int-however-it-will-be-null","children":[]},{"level":3,"title":"5.2 RowVersionAsBigInt will give you the full 8-byte rowversion as a BIGINT.","slug":"_5-2-rowversionasbigint-will-give-you-the-full-8-byte-rowversion-as-a-bigint","link":"#_5-2-rowversionasbigint-will-give-you-the-full-8-byte-rowversion-as-a-bigint","children":[]},{"level":3,"title":"5.3 In SQL Server, the rowversion data type is a unique binary number within a database that automatically increments whenever a row is inserted or updated. So, we don't need to convert to timestamp.","slug":"_5-3-in-sql-server-the-rowversion-data-type-is-a-unique-binary-number-within-a-database-that-automatically-increments-whenever-a-row-is-inserted-or-updated-so-we-don-t-need-to-convert-to-timestamp","link":"#_5-3-in-sql-server-the-rowversion-data-type-is-a-unique-binary-number-within-a-database-that-automatically-increments-whenever-a-row-is-inserted-or-updated-so-we-don-t-need-to-convert-to-timestamp","children":[]},{"level":3,"title":"5.4 The result are shown blow","slug":"_5-4-the-result-are-shown-blow","link":"#_5-4-the-result-are-shown-blow","children":[]}]},{"level":2,"title":"4. customzie RowVersion","slug":"_4-customzie-rowversion","link":"#_4-customzie-rowversion","children":[{"level":3,"title":"1. Why we need to define the customzie RowVersion?","slug":"_1-why-we-need-to-define-the-customzie-rowversion","link":"#_1-why-we-need-to-define-the-customzie-rowversion","children":[]},{"level":3,"title":"2. Using trigger define RowVersion","slug":"_2-using-trigger-define-rowversion","link":"#_2-using-trigger-define-rowversion","children":[]},{"level":3,"title":"3. code control rowversion","slug":"_3-code-control-rowversion","link":"#_3-code-control-rowversion","children":[]}]},{"level":2,"title":"5. Why Microsoft does not recommend using timestamps to replace RowVersion?","slug":"_5-why-microsoft-does-not-recommend-using-timestamps-to-replace-rowversion","link":"#_5-why-microsoft-does-not-recommend-using-timestamps-to-replace-rowversion","children":[{"level":3,"title":"1. Different Purpose and Functionality","slug":"_1-different-purpose-and-functionality","link":"#_1-different-purpose-and-functionality","children":[]},{"level":3,"title":"2. Concurrency control","slug":"_2-concurrency-control","link":"#_2-concurrency-control","children":[]},{"level":3,"title":"3. Performance","slug":"_3-performance","link":"#_3-performance","children":[]},{"level":3,"title":"4. Precision and Accuracy","slug":"_4-precision-and-accuracy","link":"#_4-precision-and-accuracy","children":[]},{"level":3,"title":"5. Functionality and Usability","slug":"_5-functionality-and-usability","link":"#_5-functionality-and-usability","children":[]},{"level":3,"title":"6. Best Practices and Recommendations","slug":"_6-best-practices-and-recommendations","link":"#_6-best-practices-and-recommendations","children":[]}]},{"level":2,"title":"6. .NET control SQLServer RowVersion","slug":"_6-net-control-sqlserver-rowversion","link":"#_6-net-control-sqlserver-rowversion","children":[{"level":3,"title":"1.Use optimistic locks to prevent duplicate commits","slug":"_1-use-optimistic-locks-to-prevent-duplicate-commits","link":"#_1-use-optimistic-locks-to-prevent-duplicate-commits","children":[]},{"level":3,"title":"precondition:","slug":"precondition","link":"#precondition","children":[]},{"level":3,"title":"Principle:","slug":"principle","link":"#principle","children":[]},{"level":3,"title":"Procedure","slug":"procedure","link":"#procedure","children":[]},{"level":3,"title":"Code(SQLSugar + SQLServer + .NET8)","slug":"code-sqlsugar-sqlserver-net8","link":"#code-sqlsugar-sqlserver-net8","children":[]}]}],"git":{"createdTime":1763103282000,"updatedTime":1763103282000,"contributors":[{"name":"jsonzhao","email":"json.zhao.cn@outlook.com","commits":1}]},"filePathRelative":"blogs/Skills/NET/RowVersion/RowVersion_en.md"}`);export{f as comp,g as data};
