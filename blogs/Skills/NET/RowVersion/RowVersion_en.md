---
title: SQL Server RowVersion in the SQL Sugar

date: 2025/11/14
tags:
 - NET
categories:
 - Skills
---

# **SQL Server RowVersion Usage**
## 1. What does rowversion do?
When a data table is updated, how do I characterize the order in which each data row is updated? The easiest way to do this is to use the RowVersion field, 
which is similar to the TimeStamp type, except that TimeStamp is obsolete and should be avoided in product design and should be replaced with RowVersion.

RowVersion is a self-incrementing data type, which is only used to define the column type of the data table, and its value occupies a fixed size of 8 bytes, 
which is a unique, binary number automatically generated by the SQL Server database, and the value is stored in binary(8).

RowVersion is used to stamp the version of each row of data in a data table, and the storage size is 8 bytes. The RowVersion data type is an eternally increasing number that does not retain a date or time, but you can use RowVersion to compare the order in which the rows of data were updated, and if @rv1<@rv2, then the update of the @rv2 occurred after the @rv1.

## 2. How is the RowVersion incremented?

Each database has only one self-incrementing count, which is the DataBase RowVersion, which is incremented each time the Insert or Update command is executed on
a table with a RowVersion field. A data table can have a maximun of one RowVersion field, and whenever you run the Insert or Update command on the data table, 
the filed will be updated to the lasted value of the counter.

### 1. Features of the Rowversion field:
1. Since each Database has only one Counter, the value of RowVersion is unique in the current databases, and the value of this field is different for all tables with 
RowVersion filed.
2. The RowVersion of the database is only incremented and not rolled back; If a transaction that updates table data(Insert or Update) is rolled back, the value of the 
RowVersion filed of the data table is rolled back, however, the RowVersion of the database is not rolled back.
3. The value is automatically assingned by the database, and can't be explicitly assigned in the Insert or Update commands.

If the current value is different from the RowVersion value of the last record,it means that the data row has been updated.

### 2. Global variables @@DBTS
Global variable @@DBTS(Database TimeStamp).The data type used to return the Rowversion of the current database, @@DBTS The return values is varbinary(8), which is unique across the entire database. The value of the counter is incremented everytime a table in the database containing the RowVersion field executeds the Insert or Update command.
The value of the @@DBTS is not rolled back,even when a transaction is rolled back, or when an Insert or Update transcation fails.
```sql
select @@DBTS
```

## 3. Next Database RowVersion
The none-deterministic function MIN_ACTIVE_ROWVERSION() is used to return the next RowVersion values of the current database, which is @@DBTS+1.
```sql
select @@DBTS as dbts, MIN_ACTIVE_ROWVERSION() as min_active
```

# 2. How to use RowVersion?
RowVersion is used to characterize the order in which rows are updated, and its value is unique in the database.

## 1. Create a RowVersion filed
Run the Created command to create a table that contains a filed type RowVersion
```sql
alter table yourtable add RowVersionStamp Rowversion;
```

## 2. Insert a new line
The value of the RowVersion field is automatically incremented and cannot be assigned to the column, however, when a row of data is inserted, the field is automatically set to the value of the global variable @@DBTS

## 3. Update the data rows
When the value of any column in the data table changes, the RowVersion field is automatically set to the value of the global variable @@DBTS

## 4. The value of the RowVersion field will not be rolled back
When an update (INSERT or UPDATE) transaction is rolled back, the value of the RowVersion field is not rolled back, the value of the @@DBTS is used:

When a transaction is rolled back, the value of the RowVersion field is not rolled back, but the value of the RowVersion field of the database is incremented, because the database counter is not in the transaction, and its value is only incremented, not rolled back, so once the value of the RowVersion field is updated, it will not be rolled back.

## 5.Convert Rowversion to int,bigint and timestamp
### 5.1 `RowVersionAsInt` will give you the lower 4 bytes as an `int`, however ,it will be null.
### 5.2 `RowVersionAsBigInt` will give you the full 8-byte rowversion as a `BIGINT`.
### 5.3 In SQL Server, the `rowversion` data type is a unique binary number within a database that automatically increments whenever a row is inserted or updated. So, we don't need to convert to `timestamp`.

```sql
select 
	id,
	RowVersionStamp,
    CAST(CAST(RowVersionStamp AS BINARY(4)) AS INT) AS RowVersionAsInt,
	CAST(RowVersionStamp AS BIGINT) AS RowVersionAsBigInt
from TestJson
```
### 5.4 The result are shown blow
<div>
    <img src="./RowversionConvertBigint.png" title="Rowversion Convert Bigint">
</div>



## 4. customzie RowVersion
### 1. Why we need to define the customzie RowVersion?
1. In some cases, we need to see how many times a table has been changed, but SQLSever's Rowversion is database level oriented, not table level oriented. And it is binary 8 bytes, can not directly represent the number of changes in the table, size, time. So, we can put the table RowVersion field we want to define as bigint,timestamp type. 
2. We control RowVersion field changes in two ways, one is a trigger, and the other is code control.

### 2. Using trigger define RowVersion
1. The advantage of a trigger defining Rowversion is that you do not need to write this logic in the code. The Database automatically changes the value of the RowVersion  
filed when it detects that the table row data has changed.
2. define RowVersion filed as Bigint
```sql
-- alter table filed
alter table your table add version bigint default 1;
-- add trigger
CREATE TRIGGER trg_yourtable_Update
ON yourtable
AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE yourtable
    SET Version = Version + 1
    FROM yourtable u
    INNER JOIN inserted i ON u.Id = i.Id;
END;
GO
```
   
3. define RowVersion as TimeStamp
```sql
-- Add the version column with default value as current timestamp
ALTER TABLE yourtable add version DATETIME2 DEFAULT (GETDATE());

-- Create the trigger to update the LastUpdated column on row update
CREATE TRIGGER trg_yourtable_version_Timestamp
ON yourtable
AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE yourtable
    SET version = GETDATE()
    FROM yourtable u
    INNER JOIN inserted i ON u.Id = i.Id;
END;

```
### 3. code control rowversion
Instead of manually modifying the data in the database table, we can modify RowVersion in the code control area and carry the RowVersion field with us every time we insert and update.

## 5. Why Microsoft does not recommend using `timestamps` to replace `RowVersion`?

### 1. Different Purpose and Functionality
- The `timestamps` data type(now referred to as `RowVersion`) is designed specificlly to support optimistic concurrency control and help with data versioning. It provides a unique binary number that changes every time a row is modified.

- `Timestamps`, as they might be thought of in other contexts(like datatime stamps), are used for recording the exact time when event occurs and are not intended to handle concurrency control or uniquely identify row versions.

### 2. Concurrency control
* `RowVersion` ensures each version of a row is unique and sequentially increments with each change, which is crucial for detecting modifications and mainttaining data
integrity in concurrent environments.
* Using a datetime-based timestamp for concurrency control can lead to collisions(two updates occurring within the same timestamp precision) and is not sequential, making it unreliable for this purpose.

### 3. Performance
* `rowversion` is efficient and optimized for version tracking by the SQL Server engine. It is stored as a binary value, ensuring minimal storage overhead and fast comparisons.
* Datetime values are larger and more complex, leading to increased storage requirements and slower performance in comparison operations, especially when dealing with high transaction volumes.
  
### 4. Precision and Accuracy
* `rowversion` guarantees unique values across the database, providing absolute accuracy in identifying changes.
* Implementing similar functionality with datetime timestamps would require additional custom logic and code, increasing the complexity and potential for errors.

### 5. Functionality and Usability
* `rowversion` integrates seamlessly with SQL Serverâ€™s native support for optimistic concurrency control, making it easy to implement and use.

### 6. Best Practices and Recommendations
* Microsoft provides comprehensive guidance and best practices for using rowversion to manage row versioning. Following these best practices ensures the database system remains reliable, performant, and easier to maintain.
* Diverging from recommended practices, like using datetime stamps for row versioning, can lead to unforeseen issues, lack of support, and increased technical debt.

In summary, Microsoft does not recommend using datetime `timestamps` to replace `rowversion` due to significant differences in functionality, precision, performance, and reliability. Sticking with the rowversion data type ensures robust concurrency control, optimal performance, and adherence to best practices in SQL Server database management.

## 6. .NET control SQLServer RowVersion 

### 1.Use [optimistic locks](https://www.sqlserver-dba.com/2012/12/sql-server-concurrency-control-optimistic-and-pessimistic.html#google_vignette) to prevent duplicate commits
### precondition:
#### 1. User open the edit UI and update the data;
#### 2. User click submit button after he or she updated all data;
### Principle:
#### 1. When the user opens the edit box for too long,someone else has modified the record, and he may delete the updated data before commiting.We need a time filed to compare with the version of the database to determine whether the data has been changed.
### Procedure
#### 1. Open two browsers, edit the same record. The user A save it first, and then the user B save it again. Finially, this scenario can be repeated.

#### 2. Because it is the same record itself does not exist concurrent, the editing interface will not refresh the data for a day.Someone submits the data will recover another submiting. 

### Code(SQLSugar + SQLServer + .NET8)
#### Entity:
```C#
public class Test
{
    [SugarColumn(IsPrimaryKey =true)]
    public long Id { get; set;}

    [SugarColumn(
             IsEnableUpdateVersionValidation = true, 
             IsOnlyIgnoreInsert=true,
             IsOnlyIgnoreUpdate=true,
             ColumnDataType="timestamp" 
              )] 
    // Only the SQL Server entity is byte, another should be timestamp or another type
    public byte[]? Version { get; set;}
    
    // additional filed
    [SugarColumn(IsIgnore = true)]
    public long TimeStampVersionLong
    {

        get => Version != null ? BitConverter.ToInt64(Version.Reverse().ToArray(), 0) : 0;
        set => Version = BitConverter.GetBytes(value).Reverse().ToArray();
    }
}
```

#### Submit Interface
```C#
[HttpPost]
[Description("PostTestData")]
public async Task<IReturnModel<VerTest>> PostTestData(Test testDto)
{  
    await _db.Updateable(testDto).IsEnableUpdateVersionValidation().Where(t=>t.Id==testDto.Id).ExecuteCommandAsync();
    var data = await  _db.Queryable<VerTest>().Where(t=>t.Id==testDto.Id).FirstAsync();
    return ReturnModel.Successful("success",data);
}
```

#### Principle
```C#
//QueryThisData, Id filed must exist and must be primary key
var data = db.Queryable<Test>().InSingle(id);
  
//Sucess (data.Version is equal to the database Version)
db.Updateable(data).IsEnableUpdateVersionValidation().ExecuteCommandAsync();//the database version will update after executed
  
//faild (data.Version is not equal to the database Version )
db.Updateable(data).IsEnableUpdateVersionValidation().ExecuteCommandAsync();

//how to know the VersionExceptions or another
//catch the exception 
throw new VersionExceptions //if the exception is  VersionExceptions , we can know this is concurrency exceptions
```